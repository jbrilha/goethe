package db

import (
	"database/sql"
	"fmt"
	"log"
	"strings"
	"time"

	"goethe/data"

	"github.com/lib/pq"
)

func InsertBlogPost(p *data.Post) (int, error) {
	tx, err := db.Begin()
	if err != nil {
		log.Println(err)
		return 0, err
	}

	defer tx.Rollback()

	query := `INSERT INTO post(creator, title, tags, content, created_at)
                VALUES($1, $2, $3, $4, $5)
                RETURNING id`

    log.Println("ptags", len(p.Tags))
	err = tx.QueryRow(
		query,
		p.Creator,
		p.Title,
		pq.Array(p.Tags),
		p.Content,
		time.Now(),
	).Scan(
		&p.ID,
	)
	if err != nil {
		log.Println(err)
		return 0, err
	}

	if err = tx.Commit(); err != nil {
		log.Println(err)
		return 0, err
	}

	return p.ID, nil
}

func IncrPostViews(id int) error {
	tx, err := db.Begin()
	if err != nil {
		log.Println(err)
		return err
	}

	defer tx.Rollback()

	query := `UPDATE post SET views = views + 1 WHERE id = $1`

	_, err = tx.Exec(query, id)

	if err != nil {
		if err == sql.ErrNoRows {
			log.Printf("nooooooooo %d", id)
			return err
		}
		log.Println("wtf", id)
		return err
	}

	if err = tx.Commit(); err != nil {
		log.Println(err)
		return err
	}

	return nil
}

func GetBlogPostByID(id int) (data.Post, error) {
	query := `SELECT * FROM post WHERE id = $1`

	post := data.Post{}

	err := db.QueryRow(query, id).Scan(
		&post.ID,
		&post.Creator,
		&post.Title,
		pq.Array(&post.Tags),
		&post.Content,
		&post.Views,
		&post.CreatedAt,
	)

	if err != nil {
		if err == sql.ErrNoRows {
			log.Printf("nooooooooo %d", id)
			return data.Post{}, err
		}
		log.Println("wtf", id)
		return data.Post{}, err
	}

	return post, nil
}

func SearchPosts(creator string, fuzzyTerms, exactTerms, tags []string) ([]data.Post, error) {
	var query strings.Builder
	args := []any{}
	offset := 1

	if creator == "" {
		query.WriteString(`SELECT * FROM post WHERE (`)
	} else {
		query.WriteString(`SELECT * FROM post WHERE creator = $1 AND (`)
		offset = 2
		args = []any{creator}
	}
	q := []string{}

	currIdx := offset
	fCount := len(fuzzyTerms)
	eCount := len(exactTerms)
	tCount := len(tags)
	if fCount > 0 {
		query.WriteString(`(`)
		log.Println("fuzzy")
		for i, term := range fuzzyTerms { // TODO already looping through terms in the handler, figure out optimization
			q = append(
				q,
				`(content ILIKE '%' || $` + fmt.Sprint(i + offset) +
					` || '%' OR title ILIKE '%' || $` + fmt.Sprint( i + offset) + ` || '%')`)
			args = append(args, term)

			currIdx = i + offset + 1
		}
		query.WriteString(strings.Join(q, ` OR `))
		query.WriteString(`)`)
	}

	if eCount > 0 {
		q = []string{}
		log.Println("exact")
		if fCount > 0 {
			query.WriteString(" AND (")
		}

		for i, term := range exactTerms {
			q = append(
				q,
				`(content ~* ('\y' || $` + fmt.Sprint(i + currIdx) +
					` || '\y') OR title ~* ('\y' || $` + fmt.Sprint(i + currIdx) + ` || '\y'))`)
			args = append(args, term)

			currIdx = i + offset + 1
		}
		query.WriteString(strings.Join(q, " OR "))

		if fCount > 0 {
			query.WriteString(")")
		}
	}

	if tCount > 0 {
		log.Println("tags")
		if fCount > 0 || eCount > 0 {
			query.WriteString(" AND (")
		}

		query.WriteString("tags && $" + fmt.Sprint(currIdx))
        args = append(args, pq.Array(tags))

		if fCount > 0 || eCount > 0 {
			query.WriteString(")")
		}
	}

	query.WriteString(`) ORDER BY created_at DESC`)

	return getPosts(query.String(), args...)
}

func SearchPostsByCreator(creator string) ([]data.Post, error) {
	query := `SELECT * FROM post WHERE creator ILIKE '%' || $1 || '%' ORDER BY created_at DESC`

	return getPosts(query, creator)
}

func SearchPostsByTag(tag string) ([]data.Post, error) {
	query := `SELECT * FROM post WHERE $1 = ANY(tags) ORDER BY created_at DESC`

	return getPosts(query, tag)
}

func GetBlogPosts() ([]data.Post, error) {
	query := `SELECT * FROM post ORDER BY created_at DESC`

	return getPosts(query)
}

func getPosts(query string, args ...any) ([]data.Post, error) {
	rows, err := db.Query(query, args...)
	if err != nil {
		if err == sql.ErrNoRows {
			log.Println("nooooooooo roooooooooooows")
		}
		log.Println(err)
	}

	defer rows.Close()

	posts := []data.Post{}

	for rows.Next() {
		var post data.Post
		err := rows.Scan(
			&post.ID,
			&post.Creator,
			&post.Title,
			pq.Array(&post.Tags),
			&post.Content,
			&post.Views,
			&post.CreatedAt,
		)
		if err != nil {
			log.Println(err)
		}

		posts = append(posts, post)
	}

	return posts, nil
}

func createPostTable() {
	// db.Exec("DROP TABLE post")
	query := `CREATE TABLE IF NOT EXISTS post(
                id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                creator VARCHAR NOT NULL,
                title VARCHAR NOT NULL,
                tags VARCHAR ARRAY DEFAULT NULL,
                content TEXT NOT NULL,
                views INT DEFAULT 0,
                created_at timestamp NOT NULL
    )`

	_, err := db.Exec(query)
	if err != nil {
		log.Println(err)
	}
}
