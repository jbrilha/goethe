package db

import (
	"database/sql"
	"fmt"
	"goethe/data"
	"log"
	"time"

	_ "github.com/lib/pq"
)

var db *sql.DB

func Init(connStr string) {
	var err error
	db, err = sql.Open("postgres", connStr)

	if err != nil {
		log.Fatal(err)
	}

	if err = db.Ping(); err != nil {
		log.Fatal(err)
	}

	createBookTable()
	createUserTable()
	createPostTable()

	// u := data.User{
	// 	Username:  "root",
	// 	Password:  "root",
	// 	Email:     "root@email.com",
	// 	CreatedAt: time.Now(),
	// }
	//
	// pk := InsertUser(u)
	// fmt.Println(pk)

}

func Close() {
	db.Close()

	log.Println("DB closed")
}

// TODO remove fatal logs; make error handler

func createBookTable() {
	db.Exec("DROP TABLE book")
	query := `CREATE TABLE IF NOT EXISTS book(
                id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                isbn13 CHAR(13),
                title VARCHAR NOT NULL,
                description TEXT,
                publishers VARCHAR[]
    )`
	//padding on the isbn to allow for hyphens, not sure if necessary

	_, err := db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}
}

func GetUserAccount(username string) data.User {
	query := `SELECT * FROM user_account WHERE username = $1`

	user := data.User{}

	err := db.QueryRow(query, username).Scan(&user.ID, &user.Username, &user.Email, &user.Password, &user.CreatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			log.Fatal(err)
		}
		fmt.Println("other err")
        log.Fatal(err)

	}

	fmt.Println("user", user)
	return user
}

func InsertUserAccount(u data.User) int {
	query := `INSERT INTO user_account(username, email, password, created_at)
                VALUES($1, $2, $3, $4)
                RETURNING id`

	var pk int

	err := db.QueryRow(query, u.Username, u.Email, u.Password, u.CreatedAt).Scan(&pk)
	if err != nil {
		log.Fatal(err)
	}

	return pk
}

func createUserTable() {
	// db.Exec("DROP TABLE user_account")
	query := `CREATE TABLE IF NOT EXISTS user_account(
                id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                username VARCHAR NOT NULL,
                email VARCHAR NOT NULL,
                password VARCHAR NOT NULL,
                created_at timestamp NOT NULL
    )`

	_, err := db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}
}

func createPostTable() {
	db.Exec("DROP TABLE post")
	query := `CREATE TABLE IF NOT EXISTS post(
                id int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                creator VARCHAR NOT NULL,
                title VARCHAR NOT NULL,
                content TEXT NOT NULL,
                created_at timestamp NOT NULL
    )`

	_, err := db.Exec(query)
	if err != nil {
		log.Fatal(err)
	}

	for _, post := range data.GetPosts() {
		InsertBlogPost(post)
	}
}

func checkTz() {
	query := `SHOW timezone`

	var tz string

	err := db.QueryRow(query).Scan(&tz)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(tz)
}

func InsertBlogPost(p data.Post) int {
	query := `INSERT INTO post(creator, title, content, created_at)
                VALUES($1, $2, $3, $4)
                RETURNING id`

	var pk int

	err := db.QueryRow(query, p.Creator, p.Title, p.Content, time.Now()).Scan(&pk)
	if err != nil {
		log.Fatal(err)
	}

	return pk
}

func GetBlogPost(id int) data.Post {
	query := `SELECT * FROM post where ID = $1`

	post := data.Post{}

	err := db.QueryRow(query, id).Scan(&post.ID,
		&post.Creator,
		&post.Title,
		&post.Content,
		&post.CreatedAt)

	if err != nil {
		if err == sql.ErrNoRows {
			log.Fatalf("nooooooooo %d", id)
		}
		fmt.Println("wtf", id)
		log.Fatal(err)
	}

	return post
}

func GetBlogPosts() []data.Post {
	query := `SELECT * FROM post`

	var id int
	var title string
	var creator string
	var content string
	var timestamp time.Time

	rows, err := db.Query(query)
	if err != nil {
		if err == sql.ErrNoRows {
			log.Fatalf("nooooooooo roooooooooooows")
		}
		log.Fatal(err)
	}

	defer rows.Close()

	posts := []data.Post{}

	for rows.Next() {
		err := rows.Scan(&id, &creator, &title, &content, &timestamp)
		if err != nil {
			log.Fatal(err)
		}

		posts = append(posts, data.Post{
			ID:        id,
			Creator:   creator,
			Title:     title,
			Content:   content,
			CreatedAt: timestamp,
		})
	}

	return posts
}
